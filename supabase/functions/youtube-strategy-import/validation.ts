/**
 * Multi-step Validation Logic for YouTube Strategy Import
 */

export interface StructuredEntryRule {
  id: string;
  type: 'smc' | 'ict' | 'indicator' | 'price_action' | 'liquidity' | 'structure';
  concept: string;
  condition: string;
  timeframe?: string;
  is_mandatory: boolean;
}

export interface StructuredExitRule {
  id: string;
  type: 'take_profit' | 'stop_loss' | 'trailing_stop' | 'time_based';
  value: number | null;
  unit: 'percent' | 'atr' | 'rr' | 'pips' | null;
  concept: string;
}

export interface ExtractedStrategy {
  strategyName: string;
  description: string;
  methodology: string;
  conceptsUsed: string[];
  indicatorsUsed: string[];
  patternsUsed: string[];
  entryRules: StructuredEntryRule[];
  exitRules: StructuredExitRule[];
  riskManagement: {
    riskRewardRatio?: number | null;
    stopLossLogic?: string | null;
    positionSizing?: string | null;
  };
  timeframeContext: {
    primary: string;
    higherTF?: string | null;
    lowerTF?: string | null;
  };
  suitablePairs: string[];
  difficultyLevel: 'beginner' | 'intermediate' | 'advanced';
  riskLevel: 'low' | 'medium' | 'high';
}

export interface ActionabilityResult {
  isActionable: boolean;
  hasEntry: boolean;
  hasExit: boolean;
  hasRiskManagement: boolean;
  warnings: string[];
  missingElements: string[];
  score: number;
}

/**
 * Validate that extracted strategy is actionable
 * Must have: entry rules, exit rules, risk management
 */
export function validateActionability(strategy: ExtractedStrategy): ActionabilityResult {
  const warnings: string[] = [];
  const missingElements: string[] = [];

  // Check entry rules
  const hasEntry = strategy.entryRules && strategy.entryRules.length > 0;
  if (!hasEntry) {
    missingElements.push('Entry rules/conditions');
  } else {
    // Validate entry rules structure
    const validEntryRules = strategy.entryRules.filter(rule => 
      rule.type && rule.condition && rule.condition.length > 10
    );
    if (validEntryRules.length === 0) {
      warnings.push('Entry rules exist but lack specific conditions');
    }
    if (validEntryRules.length < 2) {
      warnings.push('Strategy has less than 2 entry conditions (low confluence)');
    }
  }

  // Check exit rules
  const hasTakeProfit = strategy.exitRules?.some(r => r.type === 'take_profit');
  const hasStopLoss = strategy.exitRules?.some(r => r.type === 'stop_loss');
  const hasExit = hasTakeProfit || hasStopLoss;
  
  if (!hasTakeProfit) {
    missingElements.push('Take profit level');
  }
  if (!hasStopLoss) {
    missingElements.push('Stop loss level');
  }

  // Check risk management
  const rm = strategy.riskManagement || {};
  const hasRR = rm.riskRewardRatio && rm.riskRewardRatio > 0;
  const hasSLLogic = rm.stopLossLogic && rm.stopLossLogic.length > 5;
  const hasPositionSizing = rm.positionSizing && rm.positionSizing.length > 5;
  const hasRiskManagement = hasRR || hasSLLogic || hasPositionSizing;

  if (!hasRiskManagement) {
    missingElements.push('Risk management rules');
  }

  // Additional validation warnings
  if (!strategy.timeframeContext?.primary) {
    warnings.push('No primary timeframe specified');
  }

  if (strategy.suitablePairs?.length === 0) {
    warnings.push('No suitable trading pairs specified');
  }

  // Methodology-specific validation
  if (strategy.methodology === 'smc' || strategy.methodology === 'ict') {
    if (strategy.indicatorsUsed?.length > 0) {
      // This is okay - SMC/ICT can use confluence indicators
      // But if ONLY indicators and no concepts, that's suspicious
      if (strategy.conceptsUsed?.length === 0) {
        warnings.push('SMC/ICT strategy detected but no SMC concepts found');
      }
    }
    if (strategy.conceptsUsed?.length === 0) {
      missingElements.push('SMC/ICT concepts (Order Block, FVG, BOS, etc.)');
    }
  }

  if (strategy.methodology === 'indicator_based') {
    if (strategy.indicatorsUsed?.length === 0) {
      missingElements.push('Indicator specifications');
    }
  }

  // Calculate score
  let score = 100;
  score -= missingElements.length * 20;
  score -= warnings.length * 5;
  score = Math.max(0, Math.min(100, score));

  const isActionable = hasEntry && hasExit && missingElements.length <= 1;

  return {
    isActionable,
    hasEntry,
    hasExit,
    hasRiskManagement,
    warnings,
    missingElements,
    score,
  };
}

/**
 * Calculate final confidence score based on multiple factors
 */
export function calculateFinalConfidence(
  methodologyConfidence: number,
  actionabilityScore: number,
  transcriptWordCount: number,
  isAutoGeneratedCaptions: boolean
): number {
  let confidence = methodologyConfidence * 0.4 + actionabilityScore * 0.4;
  
  // Bonus for longer transcripts (more context)
  if (transcriptWordCount > 500) {
    confidence += 10;
  } else if (transcriptWordCount > 1000) {
    confidence += 15;
  }

  // Penalty for auto-generated captions (less accurate)
  if (isAutoGeneratedCaptions) {
    confidence -= 10;
  }

  return Math.max(0, Math.min(100, Math.round(confidence)));
}

/**
 * Determine import status based on confidence and validation
 */
export type ImportStatus = 'success' | 'warning' | 'blocked' | 'failed';

export function determineImportStatus(
  confidence: number,
  actionability: ActionabilityResult
): ImportStatus {
  // Failed: actionability failed completely
  if (!actionability.hasEntry && !actionability.hasExit) {
    return 'failed';
  }

  // Blocked: not actionable
  if (!actionability.isActionable) {
    return 'blocked';
  }

  // Success or Warning based on confidence
  if (confidence >= 80) {
    return 'success';
  } else if (confidence >= 60) {
    return 'warning';
  } else {
    return 'blocked';
  }
}

/**
 * Generate human-readable reason for status
 */
export function generateStatusReason(
  status: ImportStatus,
  actionability: ActionabilityResult,
  confidence: number
): string {
  switch (status) {
    case 'failed':
      return `Strategy extraction failed. Missing: ${actionability.missingElements.join(', ')}`;
    
    case 'blocked':
      if (!actionability.isActionable) {
        return `Strategy is not actionable. Missing: ${actionability.missingElements.join(', ')}`;
      }
      return `Confidence too low (${confidence}%). Manual review required.`;
    
    case 'warning':
      return `Strategy extracted with ${confidence}% confidence. Review before using.`;
    
    case 'success':
      return `Strategy extracted successfully with ${confidence}% confidence.`;
    
    default:
      return 'Unknown status';
  }
}

/**
 * Add IDs to entry/exit rules if missing
 */
export function normalizeRules(strategy: ExtractedStrategy): ExtractedStrategy {
  const normalizedEntry = (strategy.entryRules || []).map((rule, idx) => ({
    ...rule,
    id: rule.id || `entry_${idx}`,
    is_mandatory: rule.is_mandatory ?? idx < 2, // First 2 are mandatory by default
  }));

  const normalizedExit = (strategy.exitRules || []).map((rule, idx) => ({
    ...rule,
    id: rule.id || `exit_${idx}`,
  }));

  return {
    ...strategy,
    entryRules: normalizedEntry,
    exitRules: normalizedExit,
  };
}
