/**
 * YouTube Transcript Acquisition Engine
 * Fetches full video transcripts using Innertube API (no API key required)
 */

export interface TranscriptSegment {
  text: string;
  start: number;  // seconds
  duration: number;
}

export interface TranscriptResult {
  success: boolean;
  transcript?: string;
  segments?: TranscriptSegment[];
  language?: string;
  isAutoGenerated?: boolean;
  error?: string;
  videoTitle?: string;
}

/**
 * Extract video ID from various YouTube URL formats
 */
export function extractVideoId(url: string): string | null {
  const patterns = [
    /(?:youtube\.com\/watch\?v=)([a-zA-Z0-9_-]{11})/,
    /(?:youtu\.be\/)([a-zA-Z0-9_-]{11})/,
    /(?:youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
    /(?:youtube\.com\/v\/)([a-zA-Z0-9_-]{11})/,
    /(?:youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }

  return null;
}

/**
 * Fetch YouTube video transcript using Innertube API
 * This doesn't require an API key as it uses YouTube's internal player API
 */
export async function fetchYouTubeTranscript(videoId: string): Promise<TranscriptResult> {
  try {
    // Step 1: Fetch the video page to get Innertube API key
    const videoPageUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const pageResponse = await fetch(videoPageUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
        'Accept-Language': 'en-US,en;q=0.9',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Encoding': 'gzip, deflate, br',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'none',
        'Sec-Fetch-User': '?1',
        'Cache-Control': 'max-age=0',
      },
    });

    if (!pageResponse.ok) {
      console.error(`YouTube page fetch failed: ${pageResponse.status}`);
      return { 
        success: false, 
        error: `YouTube is blocking automated requests. Please provide the transcript manually using the "Paste Transcript" option.` 
      };
    }

    const pageHtml = await pageResponse.text();
    
    // Check if we got a valid YouTube page or a bot detection page
    if (pageHtml.includes('consent.youtube.com') || pageHtml.includes('To continue with your YouTube experience')) {
      console.error('YouTube consent/bot detection page received');
      return {
        success: false,
        error: 'YouTube requires consent verification. Please provide the transcript manually.',
      };
    }

    // Extract video title
    const titleMatch = pageHtml.match(/<title>([^<]+)<\/title>/);
    const videoTitle = titleMatch 
      ? titleMatch[1].replace(' - YouTube', '').trim() 
      : undefined;

    // Step 2: Extract Innertube API key from page
    const apiKeyMatch = pageHtml.match(/"INNERTUBE_API_KEY":"([^"]+)"/);
    if (!apiKeyMatch) {
      return { success: false, error: 'Could not extract Innertube API key', videoTitle };
    }
    const innertubeApiKey = apiKeyMatch[1];

    // Step 3: Extract initial player response for caption tracks
    const playerResponseMatch = pageHtml.match(/var ytInitialPlayerResponse\s*=\s*({.+?});/s);
    if (!playerResponseMatch) {
      return { success: false, error: 'Could not find player response', videoTitle };
    }

    let playerResponse;
    try {
      playerResponse = JSON.parse(playerResponseMatch[1]);
    } catch {
      return { success: false, error: 'Failed to parse player response', videoTitle };
    }

    // Step 4: Check for caption tracks
    const captionTracks = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    
    if (!captionTracks || captionTracks.length === 0) {
      // Check if captions are disabled or video is restricted
      const playabilityStatus = playerResponse?.playabilityStatus?.status;
      const reason = playerResponse?.playabilityStatus?.reason;
      
      if (playabilityStatus === 'UNPLAYABLE' || playabilityStatus === 'ERROR') {
        return {
          success: false,
          error: `Video is not accessible: ${reason || 'Unknown reason'}. Please provide the transcript manually.`,
          videoTitle,
        };
      }
      
      return { 
        success: false, 
        error: 'No captions/subtitles available for this video. Please copy the transcript from YouTube and paste it in the text area below.',
        videoTitle 
      };
    }

    // Step 5: Find the best caption track (prefer manual over auto-generated, prefer English)
    let selectedTrack = captionTracks.find((track: any) => 
      track.languageCode === 'en' && track.kind !== 'asr'
    );
    
    if (!selectedTrack) {
      selectedTrack = captionTracks.find((track: any) => track.languageCode === 'en');
    }
    
    if (!selectedTrack) {
      selectedTrack = captionTracks.find((track: any) => track.kind !== 'asr');
    }
    
    if (!selectedTrack) {
      selectedTrack = captionTracks[0];
    }

    const isAutoGenerated = selectedTrack.kind === 'asr';
    const language = selectedTrack.languageCode || 'unknown';

    // Step 6: Fetch the caption track XML
    const captionUrl = selectedTrack.baseUrl;
    const captionResponse = await fetch(captionUrl);
    
    if (!captionResponse.ok) {
      return { success: false, error: 'Failed to fetch caption track', videoTitle };
    }

    const captionXml = await captionResponse.text();

    // Step 7: Parse the XML to extract segments
    const segments: TranscriptSegment[] = [];
    const textRegex = /<text start="([\d.]+)" dur="([\d.]+)"[^>]*>([^<]*)<\/text>/g;
    
    let match;
    while ((match = textRegex.exec(captionXml)) !== null) {
      const start = parseFloat(match[1]);
      const duration = parseFloat(match[2]);
      // Decode HTML entities
      const text = match[3]
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/\n/g, ' ')
        .trim();
      
      if (text) {
        segments.push({ text, start, duration });
      }
    }

    if (segments.length === 0) {
      return { success: false, error: 'No transcript segments found', videoTitle };
    }

    // Combine segments into full transcript
    const transcript = segments.map(s => s.text).join(' ');

    return {
      success: true,
      transcript,
      segments,
      language,
      isAutoGenerated,
      videoTitle,
    };

  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    return { success: false, error: `Transcript fetch failed: ${message}` };
  }
}

/**
 * Validate transcript quality for trading strategy extraction
 */
export interface TranscriptQualityResult {
  hasActionableContent: boolean;
  hasEntryMention: boolean;
  hasExitMention: boolean;
  hasTimeframeMention: boolean;
  estimatedWordCount: number;
  warnings: string[];
}

export function validateTranscriptQuality(transcript: string): TranscriptQualityResult {
  const lowerTranscript = transcript.toLowerCase();
  const warnings: string[] = [];

  // Entry-related keywords
  const entryKeywords = [
    'entry', 'enter', 'buy', 'sell', 'long', 'short', 'open position',
    'setup', 'trigger', 'signal', 'confirmation', 'breakout', 'breakdown',
    'order block', 'fvg', 'fair value gap', 'break of structure', 'bos',
    'rsi', 'macd', 'ema', 'sma', 'moving average', 'support', 'resistance',
    'pullback', 'retest', 'rejection', 'wick', 'candle close',
    'killzone', 'optimal trade entry', 'ote', 'liquidity', 'sweep'
  ];
  const hasEntryMention = entryKeywords.some(kw => lowerTranscript.includes(kw));

  // Exit-related keywords
  const exitKeywords = [
    'exit', 'take profit', 'tp', 'stop loss', 'sl', 'close position',
    'target', 'risk reward', 'rr', '1:2', '1:3', 'trailing stop',
    'partial', 'scale out', 'move stop', 'break even', 'be'
  ];
  const hasExitMention = exitKeywords.some(kw => lowerTranscript.includes(kw));

  // Timeframe keywords
  const timeframeKeywords = [
    'm1', 'm5', 'm15', 'm30', 'h1', 'h4', 'd1', 'w1',
    '1 minute', '5 minute', '15 minute', '1 hour', '4 hour',
    'daily', 'weekly', 'higher timeframe', 'htf', 'lower timeframe', 'ltf',
    'scalp', 'day trade', 'swing', 'position'
  ];
  const hasTimeframeMention = timeframeKeywords.some(kw => lowerTranscript.includes(kw));

  // Word count
  const estimatedWordCount = transcript.split(/\s+/).filter(w => w.length > 0).length;

  // Generate warnings
  if (!hasEntryMention) {
    warnings.push('No clear entry conditions mentioned');
  }
  if (!hasExitMention) {
    warnings.push('No clear exit/risk management mentioned');
  }
  if (!hasTimeframeMention) {
    warnings.push('No timeframe context mentioned');
  }
  if (estimatedWordCount < 100) {
    warnings.push('Transcript is very short (less than 100 words)');
  }

  const hasActionableContent = hasEntryMention && hasExitMention && estimatedWordCount >= 50;

  return {
    hasActionableContent,
    hasEntryMention,
    hasExitMention,
    hasTimeframeMention,
    estimatedWordCount,
    warnings,
  };
}
