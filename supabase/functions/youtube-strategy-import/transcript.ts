/**
 * YouTube Transcript Acquisition Engine
 * Fetches full video transcripts using Innertube API (no API key required)
 */

export interface TranscriptSegment {
  text: string;
  start: number;  // seconds
  duration: number;
}

export interface TranscriptResult {
  success: boolean;
  transcript?: string;
  segments?: TranscriptSegment[];
  language?: string;
  isAutoGenerated?: boolean;
  error?: string;
  videoTitle?: string;
}

/**
 * Extract video ID from various YouTube URL formats
 */
export function extractVideoId(url: string): string | null {
  const patterns = [
    /(?:youtube\.com\/watch\?v=)([a-zA-Z0-9_-]{11})/,
    /(?:youtu\.be\/)([a-zA-Z0-9_-]{11})/,
    /(?:youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
    /(?:youtube\.com\/v\/)([a-zA-Z0-9_-]{11})/,
    /(?:youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }

  return null;
}

/**
 * Fetch YouTube video transcript using Innertube API
 * This doesn't require an API key as it uses YouTube's internal player API
 */
export async function fetchYouTubeTranscript(videoId: string): Promise<TranscriptResult> {
  try {
    // Step 1: Fetch the video page to get Innertube API key
    const videoPageUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const pageResponse = await fetch(videoPageUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept-Language': 'en-US,en;q=0.9',
      },
    });

    if (!pageResponse.ok) {
      return { success: false, error: `Failed to fetch video page: ${pageResponse.status}` };
    }

    const pageHtml = await pageResponse.text();

    // Extract video title
    const titleMatch = pageHtml.match(/<title>([^<]+)<\/title>/);
    const videoTitle = titleMatch 
      ? titleMatch[1].replace(' - YouTube', '').trim() 
      : undefined;

    // Step 2: Extract Innertube API key from page
    const apiKeyMatch = pageHtml.match(/"INNERTUBE_API_KEY":"([^"]+)"/);
    if (!apiKeyMatch) {
      return { success: false, error: 'Could not extract Innertube API key', videoTitle };
    }
    const innertubeApiKey = apiKeyMatch[1];

    // Step 3: Extract initial player response for caption tracks
    const playerResponseMatch = pageHtml.match(/var ytInitialPlayerResponse\s*=\s*({.+?});/s);
    if (!playerResponseMatch) {
      return { success: false, error: 'Could not find player response', videoTitle };
    }

    let playerResponse;
    try {
      playerResponse = JSON.parse(playerResponseMatch[1]);
    } catch {
      return { success: false, error: 'Failed to parse player response', videoTitle };
    }

    // Step 4: Check for caption tracks
    const captionTracks = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
    
    if (!captionTracks || captionTracks.length === 0) {
      return { 
        success: false, 
        error: 'No captions available for this video. Please provide the transcript manually.',
        videoTitle 
      };
    }

    // Step 5: Find the best caption track (prefer manual over auto-generated, prefer English)
    let selectedTrack = captionTracks.find((track: any) => 
      track.languageCode === 'en' && track.kind !== 'asr'
    );
    
    if (!selectedTrack) {
      selectedTrack = captionTracks.find((track: any) => track.languageCode === 'en');
    }
    
    if (!selectedTrack) {
      selectedTrack = captionTracks.find((track: any) => track.kind !== 'asr');
    }
    
    if (!selectedTrack) {
      selectedTrack = captionTracks[0];
    }

    const isAutoGenerated = selectedTrack.kind === 'asr';
    const language = selectedTrack.languageCode || 'unknown';

    // Step 6: Fetch the caption track XML
    const captionUrl = selectedTrack.baseUrl;
    const captionResponse = await fetch(captionUrl);
    
    if (!captionResponse.ok) {
      return { success: false, error: 'Failed to fetch caption track', videoTitle };
    }

    const captionXml = await captionResponse.text();

    // Step 7: Parse the XML to extract segments
    const segments: TranscriptSegment[] = [];
    const textRegex = /<text start="([\d.]+)" dur="([\d.]+)"[^>]*>([^<]*)<\/text>/g;
    
    let match;
    while ((match = textRegex.exec(captionXml)) !== null) {
      const start = parseFloat(match[1]);
      const duration = parseFloat(match[2]);
      // Decode HTML entities
      const text = match[3]
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/\n/g, ' ')
        .trim();
      
      if (text) {
        segments.push({ text, start, duration });
      }
    }

    if (segments.length === 0) {
      return { success: false, error: 'No transcript segments found', videoTitle };
    }

    // Combine segments into full transcript
    const transcript = segments.map(s => s.text).join(' ');

    return {
      success: true,
      transcript,
      segments,
      language,
      isAutoGenerated,
      videoTitle,
    };

  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    return { success: false, error: `Transcript fetch failed: ${message}` };
  }
}

/**
 * Validate transcript quality for trading strategy extraction
 */
export interface TranscriptQualityResult {
  hasActionableContent: boolean;
  hasEntryMention: boolean;
  hasExitMention: boolean;
  hasTimeframeMention: boolean;
  estimatedWordCount: number;
  warnings: string[];
}

export function validateTranscriptQuality(transcript: string): TranscriptQualityResult {
  const lowerTranscript = transcript.toLowerCase();
  const warnings: string[] = [];

  // Entry-related keywords
  const entryKeywords = [
    'entry', 'enter', 'buy', 'sell', 'long', 'short', 'open position',
    'setup', 'trigger', 'signal', 'confirmation', 'breakout', 'breakdown',
    'order block', 'fvg', 'fair value gap', 'break of structure', 'bos',
    'rsi', 'macd', 'ema', 'sma', 'moving average', 'support', 'resistance',
    'pullback', 'retest', 'rejection', 'wick', 'candle close',
    'killzone', 'optimal trade entry', 'ote', 'liquidity', 'sweep'
  ];
  const hasEntryMention = entryKeywords.some(kw => lowerTranscript.includes(kw));

  // Exit-related keywords
  const exitKeywords = [
    'exit', 'take profit', 'tp', 'stop loss', 'sl', 'close position',
    'target', 'risk reward', 'rr', '1:2', '1:3', 'trailing stop',
    'partial', 'scale out', 'move stop', 'break even', 'be'
  ];
  const hasExitMention = exitKeywords.some(kw => lowerTranscript.includes(kw));

  // Timeframe keywords
  const timeframeKeywords = [
    'm1', 'm5', 'm15', 'm30', 'h1', 'h4', 'd1', 'w1',
    '1 minute', '5 minute', '15 minute', '1 hour', '4 hour',
    'daily', 'weekly', 'higher timeframe', 'htf', 'lower timeframe', 'ltf',
    'scalp', 'day trade', 'swing', 'position'
  ];
  const hasTimeframeMention = timeframeKeywords.some(kw => lowerTranscript.includes(kw));

  // Word count
  const estimatedWordCount = transcript.split(/\s+/).filter(w => w.length > 0).length;

  // Generate warnings
  if (!hasEntryMention) {
    warnings.push('No clear entry conditions mentioned');
  }
  if (!hasExitMention) {
    warnings.push('No clear exit/risk management mentioned');
  }
  if (!hasTimeframeMention) {
    warnings.push('No timeframe context mentioned');
  }
  if (estimatedWordCount < 100) {
    warnings.push('Transcript is very short (less than 100 words)');
  }

  const hasActionableContent = hasEntryMention && hasExitMention && estimatedWordCount >= 50;

  return {
    hasActionableContent,
    hasEntryMention,
    hasExitMention,
    hasTimeframeMention,
    estimatedWordCount,
    warnings,
  };
}
